#!/usr/bin/env perl

use strict;
use warnings;

use FindBin;
use Time::Piece;

my %dataSets = (
    'tank'               => '',
    'tank/source'        => 'src',
    'tank/source/child'        => 'src',
    'tank/source/child/grandchild'        => 'src',
    'backup'             => '',
    'backup/destination' => 'dst',
    'remote'             => '',
    'remote/destination' => 'dst',
);

sub print_zfs_get {
    # Arguments are all optional; defaults are matched for the legacy tests
    my $prefix = shift; # Dataset name to prepend (and add a whitespace)
    my $srcname = shift;
    my $dstname = shift;

    if ( defined($prefix) ) {
        chomp $prefix;
        if (!defined($srcname) || $srcname eq '') { $srcname = $prefix; }
    } else {
        $prefix = "";
        if (!defined($srcname) || $srcname eq '') { $srcname = 'tank/source'; }
    }

    # Note: for DST we only use the pool-less part,
    # its prefix differs for local and remote.
    # More so for the legacy auto-guesswork codepath.
    if (!defined($dstname) || $dstname eq '') {
        if ($prefix eq 'tank/source' || $prefix eq '') {
            $dstname = 'destination';
        } else {
            $dstname = 'destination/' . $prefix;
        }
    }

    if ($prefix ne '') { $prefix .= " "; }

# print STDERR "===zfs get: '$prefix' '$srcname' '$dstname'\n";

    print <<"ZFS_GET_END";
${prefix}org.znapzend:dst_0_plan     1hours=>10minutes,30minutes=>5minutes,10minutes=>60seconds
${prefix}org.znapzend:dst_a_plan     1hours=>10minutes,40minutes=>5minutes,20minutes=>60seconds
${prefix}org.znapzend:dst_fail_plan  1hours=>1minutes
${prefix}org.znapzend:src            ${srcname}
${prefix}org.znapzend:src_plan       1hours=>10minutes,30minutes=>5minutes,1minutes=>6seconds
${prefix}org.znapzend:recursive      on
${prefix}org.znapzend:tsformat       %Y-%m-%d-%H%M%S
${prefix}org.znapzend:enabled        on
${prefix}org.znapzend:dst_0          backup/${dstname}
${prefix}org.znapzend:dst_a          root\@remote:remote/${dstname}
${prefix}org.znapzend:dst_fail       backup/destfail
${prefix}org.znapzend:mbuffer        $FindBin::Bin/mbuffer:31337
${prefix}org.znapzend:mbuffer_size   100M
${prefix}org.znapzend:pre_znap_cmd   /bin/echo 'pre znap command'
${prefix}org.znapzend:post_znap_cmd  /bin/echo 'post znap command'
ZFS_GET_END
} # end of print_zfs_get()

#print zfs command
print STDERR '# zfs ' . join(' ', @ARGV) . "\n";

my $command = shift @ARGV or exit 1;

for ($command){
    /^(?:set|inherit|send|recv)$/ && exit;

    #pretend snapshot to fail => snapshot does exist already
    /^snapshot$/ && exit 1;

    /^list$/ && do {
        if ($ARGV[4] && $ARGV[3] eq '-t' && $ARGV[4] eq 'snapshot'){
            if ($ARGV[-1] =~ /^[^\@]+\@[^\@]+$/){
                print $ARGV[-1] . "\n";
                exit;
            }
            exit 1 if !exists $dataSets{$ARGV[-1]};
            my $snapCount = ($dataSets{$ARGV[-1]} eq 'src') ? 60 : 58;
            #get timestamp rounded to minutes
            my $time = localtime(int(time / 60) * 60 - 3600);
            for (my $i = 0; $i < $snapCount; $i++){
                print $ARGV[-1] . '@' . $time->strftime('%Y-%m-%d-%H%M%S') . "\n";
                $time += 60;
            }
            exit;
        }
        #if there is a '/' it is a (non-root) dataset
        if ($ARGV[-1] =~ /\//){
            print "$ARGV[-1]\n" if grep { $ARGV[-1] eq $_ } keys %dataSets;
            exit;
        }
        for (sort keys %dataSets){
            print "$_\n";
        }
        exit;
    };

    /^destroy$/ && do {
        if ($ARGV[0] eq '-nv'){
            print "would reclaim 1337G\n";
        }
        exit;
    };

    /^get$/ && do {
        #if ($ARGV[6] && $ARGV[6] eq 'usedbysnapshots'){
        if ( join(" ", @ARGV) =~ /usedbysnapshots/ ){
            print "10G\n";
            exit;
        }

#print STDERR "=== zfs : recursive=" . (join(" ", @ARGV) =~ / -r / ? "Y" : "N")
#    . " ARG='$ARGV[-1]' tabledata='$dataSets{$ARGV[-1]}'\n" ;

        exit if !( (exists $dataSets{$ARGV[-1]} && $dataSets{$ARGV[-1]} eq 'src') || (join(" ", @ARGV) =~ / -r /) );

        my $prefix = "";
        my $srcds = "";
        my $srcdsOrig = "";

        if (exists $dataSets{$ARGV[-1]}) {
            $srcds = "$ARGV[-1]";
            $srcdsOrig = $srcds;
        } else {
            $srcds = "tank";
        }

        if ( join(" ", @ARGV) =~ /name,property,value/ ) {
            # The request we do when recursively looking for dataset props
            # Asked to print a prefix
            $prefix = "$srcds";
        }

        # Print a tree if either recursing from given srcds from CLI args,
        # or have none given at all (and so printing the world). Note that
        # the dataset in CLI args *must* be one from the array, otherwise
        # the mockup treats it as a random `zfs` option and ignores it.
        if (
            (join(" ", @ARGV) =~ / -r / && $srcds ne '')
         || ($srcdsOrig eq '')
        ) {
#print STDERR "=== zfs : recursive=" . (join(" ", @ARGV) =~ / -r / ? "Y" : "N")
#    . " srcds='$srcds' srcdsOrig='$srcdsOrig' prefix='$prefix'\n" ;

            # Note that listing `zfs get -r -o property,value all dataset`
            # with both this code and real ZFS returns a lot of repetitive
            # lines (same keys, different values) for dataset's children
            # that you can't really tell apart without the "name" column.

            # Per checks above we know the $prefix is empty or exactly
            # last ARGV item.
            if ($dataSets{$srcds} eq 'src') {
                print_zfs_get ($prefix, $srcds);
            }

            # Does the srcds (from prefix or defaulted) have any descendants?
            for my $childds (sort(keys %dataSets)) {
                if ( $childds =~ /^$srcds\// ) {
                    if ($dataSets{$childds} eq 'src') {
                        print_zfs_get ( ($prefix eq '') ? '' : $childds, $childds);
                    }
                }
            }
        } else {
            if ($dataSets{$ARGV[-1]} eq 'src') {
                print_zfs_get ($prefix);
            }
        }
        exit;
    };

    exit 1;
}

1;
